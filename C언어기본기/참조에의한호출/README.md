# Call by reference..

- 함수 혹은 프로시저를 호출할 때 인자를 다루는 방법 중 하나.
    - 주소에 의한 호출(Call by address)와 비슷하지만 다르다
    - 참조에 의한 호출은 함수에서 함수 외부의 메모리 공간을 참조 할 때 사용
    - 함수 선언시 매개변수에 &을 사용해 변수의 위치를 받도록 하고
    - 함수 내부에서는 위치를 준 변수를 일반 변수처럼 사용
    - Call by value는 알지?

- 함수를 호출할 때는 원칙적으로 피호출부에서 반환값을 제외하고 어떤 변수도 변경할 수 없다.
- 그리고 모든 함수는 매개변수를 '복사' 방식으로 전달받는다.
- 함수는 반환값 하나만 가질 수 있고
- 데이터를 담은 버퍼 오브젝트 등은 복사에 들어가는 부담이 크기 때문에 모든걸 원칙적으로 처리하기 힘들다.

- 함수는 포인터나 참조자를 통해 메모리를 직접 액세스 하는 방식으로 자신에게 주어진 격리 공간을 탈출
- 외부세계에 간섭하는 것이 가능하다.
- 똑같은 값에 의한 호출이지만, 전달하는 값 그 자체가 메모리 주소 즉 포인터 값이다.
- 함수 내부에서는 포인터 역참조 연산자를 통해 해당 메모리 주소를 직접 접근해 값을 수정함으로써 호출부의 메모리 공간에 직접 엑세스 한다.
- 이걸 편의상 참조에 의한 호출이라고 한다.

- 객체는 참조에 의한 호출로 생성 된다.

## 메모리에서의 이해
- 프로그래밍 언어론에서 정의하는 function은 본래의 프로그램과 완벽히 분리되어 어떤 Side Effect도 일으키지 않는 구조적인 코드 블럭을 의미한다.
- Function은 Stack Frame이라는 메모리 구조를 통해서 만들어 질 수 있다.
- 대부분의 언어에서 지원해주는 Function은 이러한 메모리 구조를 바탕으로 이루어져있고, 파라미터에 해당하는 부분 또한 스택 프레임에 저장된다.

- Stack Frame의 파라미터에 저장되는 값이 리터럴 형태의 상수인지, 아니면 어떤 변수를 가르키는 포인터 값이냐에 따라서, 파라미터를 Call by Value와 Call by Reference로 구분 할 수 있다.
- 참조에 의한 호출은 스택 프레임의 파라미터에 지정되는 값이 어떠한 변수의 주소값을 가르킨다.
- 사이드 이펙트를 일으킬 수 있다.

```c
void functionA(int value) {
    value++;
}

int main(void) {
    int a = 10;
    functionA(a);
    printf("%d\n", a);
    return 0;
}
```

결과값은 10이 나옴.
- main 함수내의 변수 a의 값을 함수 내에서 바꿀 수 없다.

```c
void functionB(int *value){
    *(value)++;
}

int main(void) {
    int a = 10;
    functionB(&a);
    printf("%d\n", a);
    return 0;
}
```